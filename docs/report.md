# 作业报告

李乐程 李奕杉 闵安娜





## 成员分工

李乐程：元数据管理模块、并发控制模块、重启恢复模块

李奕杉：查询模块、存储模块、查询优化、页表

闵安娜：存储模块



## 系统设计

在提供的框架上进一步扩展。

#### 元数据管理模块

假设有一个数据库test被创建，其元数据会按照以下结构进行存储：

```
└── thssdb
    └── data
        ├── manager.script
        └── test
            └── test.script
```

其中`manager.script`存储所有数据库的创建纪录，每个数据库有各自的`.script`档案，存储表的创建纪录。每次启动时会读取`manager.script`，将存在的数据库写入内存并递归读取该数据库的`.script`档案，写入被纪录的表。以上文件在用户操作时自动创建修改，并用于系统重启时加载数据。

元数据以SQL语句的形式存储在`.script`文件中，打开数据库服务器时读取，对数据库、表级别的操作会修改`.script`文件。

#### 存储模块

存储模块采用框架的存储结构，使用B+树来存储数据而非数据的位置。序列化的对象类型为`ArrayList<Row>`，值为`Table`的成员变量`index`的叶节点的`Row`。
序列化对象转换为对象输出流，存储在外存中。在读取时，将对象输出流转换为序列化对象，再将其转换为`ArrayList<Row>`，存储在内存中。
下图为与存储结构相关的部分类图：

                                      +-----------------+
                                      |     Database    |
                                      +-----------------+
                                      | - tables: Map<String, Table> |
                                      +-----------------+
                                                |
                                                |
                                                v
                                      +-----------------+
                                      |      Table      |
                                      +-----------------+
                                      | - tableName: String           |
                                      | - columns: List<Column>       |
                                      | - primaryKey: Column          |
                                      | - index: BPlusTree            |
                                      +-----------------+
                                                |
                                                |
                                                v
                                      +-----------------+
                                      |        Row      |
                                      +-----------------+
                                      | - entries: List<Entry>        |
                                      +-----------------+
                                                |
                                                |
                                                v
                                      +-----------------+
                                      |       Entry     |
                                      +-----------------+
                                      | - column: Column              |
                                      | - value: Object               |
                                      +-----------------+

数据库支持五种数据类型：`Int`，`Long`，`Float`，`Double`，`String`，用枚举类`ColumnType`中相应的常量标识，该类的成员函数`checkType`以某一对象为参数，返回该对象对应的`ColumnType`枚举类型，如果该对象不属于这五种数据类型则抛出`IllegalTypeException`异常。

###### 页表处理

进一步，为了处理性能测试中的大量数据与极端低内存，我们引入了页表，我们将B+树的叶节点只存储主键，而将数据存储在外存中，以减少内存的使用。
同时，我们将表分页存储在外存中，以减少大文件读写的时间，提升I/O效率。我们使用`BufferedOutputStream`和`BufferedInputStream`来减少I/O次数，提升I/O效率。
因为大部分情况下会使用`auto commit`，每次执行指令都需要持久化，所以使用页表可以减少大量的持久化时间。
如果不使用页表，我们需要将所有数据都存储在内存中，这样会导致内存不足，而且大文件读写的时间会很长，导致性能下降。
但是在进行查询时，我们可能无法一次读取到页面中的所有数据，可能会导致多次查询，但是这种情况下，使用小文件读写的时间会比较短，所以我们认为这种情况下使用页表不会影响性能。


#### 查询模块

查询模块的实现要求包括支持基础要求中的全部语句，支持多层逻辑运算符和非空判断的where条件，支持无限`join`。

在查询模块中，首先使用Antlr4生成SQL语句的语法树。然后，通过Visitor模式解析语法树，将中间组件封装成相应的类，并根据操作生成对应的Plan类。最后，调用Plan类的do方法执行语句并返回结果。

对于SQL解析过程，针对进阶要求对SQL语法进行修改，并重载SQLBaseVisitor中与实现功能相关的visit方法，逐层解析SQL语句并转化为Plan包下的类。并且针对语句，对语法错误的多种情况（如缺少可能的关键词）提供报错与可能的修改建议。

对于`select`语句的解析过程，包括`select`部分、`from`部分、`where`部分。每个部分返回相应的数据结构，如`SelectContent`、`MultipleCondition`，用于后续的语句执行。

###### 查询优化
对于性能测试中的情况，我们针对查询(`where`)语句进行了优化，主要包括以下几个方面：
1. 查询语句中条件为主键: 一般的查询需要线性搜索遍历整个表，而对于主键的查询，我们可以直接通过B+树的索引找到对应的叶节点，从而减少遍历次数。
2. 连接条件为主键: 对于连接条件为主键的连接，我们可以直接通过B+树的索引找到对应的叶节点，从而减少遍历次数。
3. 同时包括连接和筛选: 对于连接并且需要筛选的情况，我们先筛选再连接，从而减少遍历次数。

#### 并发控制模块

我们实现了`LockManager`以纪录每个客户端调用的锁和表，并存储在支持并行的`ConcurrentHashMap`中。当用户提交时，`LockManager`会释放持有的锁以及对相应表进行持久化。

每一个客户端有一个独立的`lockManager`，用于纪录用户在操作过程中使用过的锁，以及纪录用户的隔离级别。

目前数据库对象没有锁。

每一个表对象都有一个读写锁。多个用户对同一个表进行读/写操作时，会向同一个表对象申请锁，若申请失败会进入阻塞等待直到取得锁。考虑到进一步对元组设锁并不易管理，而对表设锁虽然效率低但能保障一致性。

本模块共实现两种隔离级别，`serializable`和`read committed`。当用户处于`serializable`模式时，读锁和写锁都只会在事务结束时才释放。当用户处于`read committed`模式时，写锁只会在事务结束时才释放，而读锁会在提取资料后随即释放。

当用户输入`commit`指令（之前输入了`begin transaction`指令或者只输入单句SQL语句(auto commit)，系统响应后会遍历已纪录的读写锁，若有持有的锁就释放，最后清空锁表等待下一次事务操作。

Java提供的`ReentrantReadWriteLock`不支持锁升级，因此持有读锁而要申请写锁时需要首先释放读锁。这导致了锁被中途抢占的风险，我们采用`LockManager`对锁进行管理，确保锁的申请和释放的顺序。

#### 重启恢复模块

系统为每个`Database`增设一个`Logger`，用于控制数据库的日志纪录。将操作以SQL语句的形式存储在日志文件中。
系统只有在事务进行期间才会进行纪录，而且在事务结束持久化时清空日志，在重启时会读取日志以恢复未提交的操作。支持单一事务的恢复。
系统在启动时会读取日志文件，恢复未提交的操作。而主机如果检测到客户端断开连接，会将该客户端的操作进行持久化，以防止数据丢失。


## 测试报告

功能测试


性能测试



## 进阶功能

1. 查询优化：对于查询条件为主键的查询，直接返回结果，不需要遍历整个表；对于连接条件为主键的连接，采用索引进行连接，减少遍历次数；如果连接并且需要筛选，先筛选再连接。
2. 页表：降低内存使用，减少大文件读写，提升I/O效率。
3. 查询额外语句:支持无限join，支持where子句中的多层逻辑运算符和非空判断。
4. 将数据以序列化对象的形式存储在外存中，节约空间